function extraxt_schema_ty(schema)
{
    if ( !schema )
        return;

    if ( "properties" in schema )
    {
        let ty_prop = schema.properties.ty;
        if ( !ty_prop )
            return;
        return ty_prop.const;
    }

    for ( let prop of ["oneOf", "anyOf", "allOf"] )
    {
        if ( schema[prop] )
        {
            for ( let sub_schema of schema[prop] )
            {
                let ty = extraxt_schema_ty(sub_schema);
                if ( ty !== undefined )
                    return ty;
            }
        }
    }
}

function patch_docs_links(schema, url, name, docs_name, within_properties)
{
    if ( typeof(schema) == "object" )
    {
        if ( Array.isArray(schema) )
        {
            for ( let item of schema )
                patch_docs_links(item, url, name);
        }
        else
        {
            for ( let [pname, val] of Object.entries(schema) )
            {
                var sub_name = name;
                if ( within_properties )
                    sub_name += "." + pname;

                patch_docs_links(val, url, sub_name, docs_name, pname == "properties");
            }

            if ( !within_properties )
            {
                schema._docs = url;
                schema._docs_name = docs_name;
                schema._name = name;
            }
        }
    }
}

function kebab_to_title(kebab)
{
    return kebab.split("-").map(chunk => chunk.charAt(0).toUpperCase() + chunk.substring(1).toLowerCase()).join(" ");
}

class Validator
{
    constructor(AjvClass, schema_json)
    {
        this.schema = schema_json;
        this.defs = this.schema["$defs"];
        for ( let [cat, sub_schemas] of Object.entries(this.defs) )
        {
            let cat_docs = `/lottie-spec/specs/${cat}/`;
            let cat_name = kebab_to_title(cat.replace(/s$/, ""));
            for ( let [obj, sub_schema] of Object.entries(sub_schemas) )
            {
                let obj_docs = cat_docs;
                let obj_name = cat_name;
                if ( sub_schema.type && obj != "base-gradient" )
                {
                    obj_docs += "#" + obj;
                    obj_name = kebab_to_title(obj);
                }
                patch_docs_links(sub_schema, obj_docs, obj_name, obj_name);
            }
        }
        console.log(this.schema);

        let schema_id = this.schema["$id"];
        this._extract_ty_discriminated_schema(schema_id, "layers", "all-layers"),
        this._extract_ty_discriminated_schema(schema_id, "shapes", "all-graphic-elements"),

        this.validator = new AjvClass({
            allErrors: true,
            verbose: true,
            // inlineRefs: false,
            // strict: false,
            keywords: [
                {keyword: ["_docs", "_name", "_docs_name"]},
                {
                    keyword: "ty_oneof",
                    validate: function validate_ty(schema, data, parent_schema, data_cxt)
                    {
                        // Error will be generated by required
                        if ( data.ty === undefined )
                            return true;

                        var sub_schema = schema[data.ty];
                        if ( sub_schema === undefined )
                        {
                            validate_ty.errors = [{
                                message: `has unknown 'ty' value ${data.ty}`,
                                type: "warning",
                                instancePath: data_cxt.instancePath,
                                parentSchema: parent_schema,
                            }];
                            return false;
                        }

                        var validate = this.getSchema(sub_schema);
                        if ( !validate(data, data_cxt) )
                        {
                            validate_ty.errors = validate.errors;
                            return false;
                        }
                        return true;
                    }
                }
            ],
            schemas: [this.schema]
        });
        this._validate_internal = this.validator.getSchema(schema_id);

    }

    _extract_ty_discriminated_schema(id_base, category, all)
    {

        let found = {};
        for ( let [name, sub_schema] of Object.entries(this.defs[category]) )
        {
            let ty = extraxt_schema_ty(sub_schema);
            if ( ty !== undefined )
            {
                let id = `${id_base}#/$defs/${category}/${name}`;
                found[ty] = id;
            }
        }
        this.defs[category][all].ty_oneof = found;
        this.defs[category][all].oneOf = undefined;

        return found;
    }

    validate(string)
    {
        var data;
        try {
            data = JSON.parse(string);
        } catch(e) {
            return [{
                type: "error",
                name: "Document",
                message: "is not a valid JSON file",
            }];
        }

        let errors = [];
        if ( !this._validate_internal(data) )
            errors = this._validate_internal.errors.map(e => this._cleaned_error(e));

        return errors.sort((a, b) => {
            if ( a.path < b.path )
                return -1;
            if ( a.path > b.path )
                return 1;
            return 0;
        });
    }

    _cleaned_error(error, prefix="")
    {
        /// TODO remove
        console.log(error);
        return {
            type: error.type ?? "error",
            message: error.message,
            path: prefix + (error.instancePath ?? ""),
            name: error.parentSchema?._name ?? "Value",
            docs_name: error.parentSchema?._docs_name ?? "Value",
            docs: error.parentSchema?._docs,
        };
    }

}

