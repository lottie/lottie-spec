function extraxt_schema_ty(schema)
{
    if ( !schema )
        return;

    if ( "properties" in schema )
    {
        let ty_prop = schema.properties.ty;
        if ( !ty_prop )
            return;
        return ty_prop.const;
    }

    for ( let prop of ["oneOf", "anyOf", "allOf"] )
    {
        if ( schema[prop] )
        {
            for ( let sub_schema of schema[prop] )
            {
                let ty = extraxt_schema_ty(sub_schema);
                if ( ty !== undefined )
                    return ty;
            }
        }
    }
}

function patch_docs_links(schema, url, name, docs_name, within_properties)
{
    if ( typeof(schema) == "object" )
    {
        if ( Array.isArray(schema) )
        {
            for ( let item of schema )
                patch_docs_links(item, url, name, docs_name);
        }
        else
        {
            for ( let [pname, val] of Object.entries(schema) )
            {
                var sub_name = name;
                if ( within_properties )
                    sub_name += "." + pname;

                patch_docs_links(val, url, sub_name, docs_name, pname == "properties");
            }

            if ( !within_properties )
            {
                schema._docs = url;
                schema._docs_name = docs_name;
                schema._name = name;
            }
        }
    }
}

class PropertyList
{
    constructor(schema)
    {
        this.properties = new Set();
        this.references = new Set();
        this.schema = schema;
        this.resolved = false;
        this.skip = false;
    }

    valid()
    {
        return !this.skip && (this.properties.size > 0 || this.references.size > 1);
    }
}

class PropertyMap
{
    constructor()
    {
        this.map = new Map();
    }

    create(id, schema)
    {
        var map = new PropertyList(schema);
        this.map[id] = map;
        return map;
    }

    finalize()
    {
        for ( let prop_list of this.map.values() )
        {
            if ( prop_list.valid() )
                prop_list.schema.warn_extra_props = this._get_all_props(prop_list);
        }
    }

    _get_all_props(prop_list)
    {
        if ( !prop_list.resolved )
        {
            prop_list.resolved = true;
            for ( let ref of prop_list.references )
                for ( let prop of this.get_all_props(ref) )
                    prop_list.properties.add(prop);
        }

        return prop_list.properties;
    }

    get_all_props(id)
    {
        return this.map.get(id);
    }
}

function extract_all_properties(schema, id, prop_list, prop_map)
{
    if ( typeof schema != "object" || schema === null )
        return;

    if ( Array.isArray(schema) )
    {
        for ( let i = 0; i < schema.length; i++ )
            extract_all_properties(schema[i], id + `/${i}`, prop_list, prop_map);

        return;
    }

    for ( let [name, sub_schema] of Object.entries(schema) )
    {
        if ( name == "properties" )
        {
            for ( let [prop_name, prop] of Object.entries(sub_schema) )
            {
                prop_list.properties.add(prop_name);
                let prop_id = "/properties/" + prop_name;
                extract_all_properties(prop, prop_id, prop_map.create(id, prop), prop_map);
            }
        }
        else if ( name == "oneOf" )
        {
            for ( let i = 0; i < sub_schema.length; i++ )
            {
                let oneof_id = "/oneOf/" + i;
                let oneof_schema = sub_schema[i];
                extract_all_properties(oneof_schema, oneof_id, prop_map.create(id, oneof_schema), prop_map);
            }
        }
        else if ( name == "additionalProperties" )
        {
            prop_list.skip = true;
        }
        else if ( name != "not" )
        {
            extract_all_properties(sub_schema, id + "/" + name, prop_list, prop_map);
        }
    }
}


function kebab_to_title(kebab)
{
    return kebab.split("-").map(chunk => chunk.charAt(0).toUpperCase() + chunk.substring(1).toLowerCase()).join(" ");
}


function custom_discriminator(propname, fail_unknown)
{
    function validate_fn(schema, data, parent_schema, data_cxt)
    {
        var value = data[propname]

        // Error will be generated by required
        if ( value === undefined )
            return true;

        var sub_schema = schema[value];
        if ( sub_schema === undefined )
        {
            validate_fn.errors = [{
                message: `has unknown '${propname}' value ` + JSON.stringify(value),
                type: fail_unknown ? "error" : "warning",
                instancePath: data_cxt.instancePath,
                parentSchema: parent_schema,
            }];
            return false;
        }

        var validate = this.getSchema(sub_schema.id);
        if ( !validate(data, data_cxt) )
        {
            validate_fn.errors = validate.errors;
            return false;
        }
        return true;
    }

    return validate_fn;
}

class Validator
{
    constructor(AjvClass, schema_json)
    {
        this.schema = schema_json;
        this.defs = this.schema["$defs"];
        for ( let [cat, sub_schemas] of Object.entries(this.defs) )
        {
            let cat_docs = `/lottie-spec/specs/${cat}/`;
            let cat_name = kebab_to_title(cat.replace(/s$/, ""));
            for ( let [obj, sub_schema] of Object.entries(sub_schemas) )
            {
                let obj_docs = cat_docs;
                let obj_name = cat_name;
                if ( sub_schema.type && obj != "base-gradient" )
                {
                    obj_docs += "#" + obj;
                    obj_name = sub_schema.title || kebab_to_title(obj);
                }
                patch_docs_links(sub_schema, obj_docs, obj_name, obj_name);
            }
        }
        let schema_id = this.schema["$id"];
        this._patch_ty_schema(schema_id, "layers", "all-layers");
        this._patch_ty_schema(schema_id, "shapes", "all-graphic-elements");
        for ( let [pname, pschema] of Object.entries(this.defs.properties) )
        {
            if ( pname.endsWith("-property") )
                this._patch_property_schema(pschema, schema_id + "#/$defs/properties/" + pname);
        }

        var prop_map = new PropertyMap();
        this.prop_map = prop_map;
        extract_all_properties(this.defs, "#/$defs", new PropertyList(), prop_map);

        this.validator = new AjvClass({
            allErrors: true,
            verbose: true,
            // inlineRefs: false,
            // strict: false,
            keywords: [
                {keyword: ["_docs", "_name", "_docs_name"]},
                {
                    keyword: "ty_oneof",
                    validate: custom_discriminator("ty", false),
                },
                {
                    keyword: "prop_oneof",
                    validate: custom_discriminator("a", true),
                },
                {
                    keyword: "warn_extra_props",
                    validate: function warn_extra_props(schema, data, parent_schema, data_cxt)
                    {
                        warn_extra_props.errors = [];

                        if ( typeof data != "object" || data === null )
                            return true;

                        for ( let prop of Object.keys(data) )
                        {
                            if ( !schema.has(prop) )
                            {
                                warn_extra_props.errors.push({
                                    message: `has unknown property '${prop}'`,
                                    type: "warning",
                                    instancePath: data_cxt.instancePath,
                                    parentSchema: parent_schema,
                                });
                            }
                        }

                        return warn_extra_props.errors.length == 0;
                    },
                }
            ],
            schemas: [this.schema]
        });
        this._validate_internal = this.validator.getSchema(schema_id);

    }

    _patch_ty_schema(id_base, category, all)
    {

        let found = {};
        for ( let [name, sub_schema] of Object.entries(this.defs[category]) )
        {
            let ty = extraxt_schema_ty(sub_schema);
            if ( ty !== undefined )
            {
                let id = `${id_base}#/$defs/${category}/${name}`;
                found[ty] = {
                    id: id
                };
            }
        }
        this.defs[category][all].ty_oneof = found;
        delete this.defs[category][all].oneOf;

        return found;
    }

    _patch_property_schema(schema, id)
    {
        if ( id.endsWith("gradient-property") )
        {
            return this._patch_property_schema(schema.properties.k, id + "/properties/k");
        }

        schema.prop_oneof = [];
        for ( let opt of schema.oneOf )
        {
            schema.prop_oneof.push({
                schema: {
                    type: "object",
                    ...opt
                },
                id: id + "/prop_oneof/" + schema.prop_oneof.length + "/schema",
            });
        }
        delete schema.oneOf;
    }

    validate(string)
    {
        var data;
        try {
            data = JSON.parse(string);
        } catch(e) {
            return [{
                type: "error",
                name: "Document",
                message: "is not a valid JSON file",
            }];
        }

        let errors = [];
        if ( !this._validate_internal(data) )
            errors = this._validate_internal.errors.map(e => this._cleaned_error(e));

        return errors.sort((a, b) => {
            if ( a.path < b.path )
                return -1;
            if ( a.path > b.path )
                return 1;
            return 0;
        });
    }

    _cleaned_error(error, prefix="")
    {
        /// TODO remove
        console.log(error);
        return {
            type: error.type ?? "error",
            message: (error.parentSchema?._name ?? "Value") + " " + error.message,
            path: prefix + (error.instancePath ?? ""),
            name: error.parentSchema?._docs_name ?? "Value",
            docs: error.parentSchema?._docs,
        };
    }
}


if ( typeof module !== undefined )
    module.exports = {Validator: Validator};
